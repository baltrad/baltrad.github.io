<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Frequently Asked Questions and User Guide: How to get your tools into the BALTRAD toolbox</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->

<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="./BALTRAD-doxlogo.png"></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Frequently Asked Questions and User Guide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">How to get your tools into the BALTRAD toolbox </div>  </div>
</div>
<div class="contents">
<div class="textblock"><dl class="date"><dt><b>Date:</b></dt><dd>January 2014 </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>2.0</dd></dl>
<p>This page contains a step-by-step tutorial on how to get your tools into the BALTRAD toolbox. It will focus on the Python Product Generation Framework (PGF) functionality available in the RAVE package described on the <a class="el" href="pgf.html">Processing data</a> page.</p>
<p>This tutoral builds on the functional name "hello"; this is the tool that we will integrate into the toolbox. "Hello" doesn't actually do anything very useful, and the same functionality actually already exists. However, it's intended to be a simple example that can serve as a template for integrating more useful functionality.</p>
<ul>
<li><a class="el" href="toolbox.html#toolbox_dld">Download the tutorial</a> </li>
<li><a class="el" href="toolbox.html#toolbox_C">C code</a> </li>
<li><a class="el" href="toolbox.html#toolbox_Cmake">C build directives</a> </li>
<li><a class="el" href="toolbox.html#toolbox_PyC">Write a Python C wrapper</a> </li>
<li><a class="el" href="toolbox.html#toolbox_PyCmake">Wrapper build directives</a> </li>
<li><a class="el" href="toolbox.html#toolbox_ut">Write unit tests</a> </li>
<li><a class="el" href="toolbox.html#toolbox_cmd">Write a command-line tool</a> </li>
<li><a class="el" href="toolbox.html#toolbox_qp">Create quality plugin</a> </li>
<li><a class="el" href="toolbox.html#toolbox_pgf">Create a PGF plugin</a> </li>
<li><a class="el" href="toolbox.html#toolbox_beast">Integrate with Beast and BALTRAD node</a> </li>
<li><a class="el" href="toolbox.html#toolbox_rec">Final recommendations</a></li>
</ul>
<h2><a class="anchor" id="toolbox_dld"></a>
Download the tutorial</h2>
<p>This first step is optional, but it contains a <a href="hello/hello.tgz">ready-made package</a> containing all the code, build directives, and other useful things that can be installed on top of an existing RAVE. While this may be convenient to do, it is advisable not to; instead unpack the tarball seperately and refer to it.</p>
<h2><a class="anchor" id="toolbox_C"></a>
C code</h2>
<p>The "hello" code base exists as a C file (<a href="hello/hello.c">hello.c</a>) with associated header (<a href="hello/hello.h">hello.h</a>).</p>
<p>The location of these files is important. If the functionality can be considered part of the core toolbox, then it can be placed in the <em>librave/toolbox</em> directory. Otherwise, it's advisable to put such code in a separate directory under <em>librave</em>, as has been done for the <em>scansun</em> and <em>radvol</em> code.</p>
<p>The functionality takes an I/O container object and queries its contents, checking whether it is a scan, a polar volume, an image, or a vertical profile. It also writes a new metadata attribute to the top-level 'how' group containing a simple greeting. All this is done using the toolbox APIs.</p>
<h2><a class="anchor" id="toolbox_Cmake"></a>
C build directives</h2>
<p>The <em>Makefile</em> for the C code must be modified to build the "hello" code. Edit the existing <em>Makefile</em> or use it as a template.</p>
<p>add hello.c to $RAVESOURCES</p>
<p>add hello.h to $INSTALL_HEADERS</p>
<h2><a class="anchor" id="toolbox_PyC"></a>
Write a Python C wrapper</h2>
<p>This task may seem daunting at first, but it's pretty straight-forward. Most of the code is boiler-plate, so wrappers can be recycled and used as templates a lot of the time. In the <em>modules</em> directory, create a wrapper called <a href="hello/pyhello.c">pyhello.c</a>. In contrast to the separation between core functionality and other functionality, all the wrappers are located in this <em>modules</em> directory.</p>
<p>The function containing the wrapper itself is called <em>_hello_func</em>. You can see how the function maps the input object from Python to C, calls the "hello" function in the C code, and then returns the result back to Python.</p>
<h2><a class="anchor" id="toolbox_PyCmake"></a>
Wrapper build directives</h2>
<p>Similarly with the pure C code above in <a class="el" href="toolbox.html#toolbox_Cmake">C build directives</a>, the wrapper must be built as well. Wrappers are numbered. In this tutorial, the number used for "hello" is 35. As the toolbox continues to develop, this number will be used by another module, so using a higher number will be required for "hello".</p>
<p>add SOURCE_35, OBJECTS_35, TARGET_35</p>
<p>Above ".PHONY=install", add an entry for $(TARGET_35)</p>
<p>Last line, add: -include $(SOURCE_35:%.c=/%.P)</p>
<p>After these additions, you can now build and install the C code and its Python wrapper.</p>
<h2><a class="anchor" id="toolbox_ut"></a>
Write unit tests</h2>
<p>This step shoudn't be forgotten, because it provides a safeguard for the functionality you are contributing. If the code base is altered in a way that breaks your tool, then it should result in failed tests that will alert you.</p>
<p>As with the Python wrappers, all the unit tests are located in the <em>test/pytest</em> directory. They are written in Python. We will contribute a module called <a href="hello/PyHelloTest.py">PyHelloTest.py</a> that contains two unit tests.</p>
<p>The first test <em>testHello</em> reads a polar volume file and determines that it is, indeed, a polar volume. The second test <em>testGoodbye</em> reads an improperly encoded vertical profile file and determines that it is, indeed, unrecognizable as a vertical profile.</p>
<p>Import this unit test module into <em>test/pytest/RaveTestSuite.py</em>:</p>
<div class="fragment"><pre class="fragment">
from PyHelloTest import *
</pre></div><p>Run the tests from the top directory where you are building RAVE:</p>
<div class="fragment"><pre class="fragment">
$ make test
</pre></div><p>This should result in a message at the end stating</p>
<div class="fragment"><pre class="fragment">
Ran XXX tests in X.---s

OK
</pre></div><h2><a class="anchor" id="toolbox_cmd"></a>
Write a command-line tool</h2>
<p>Because the "hello" functionality already exists in the toolbox, it's a piece of cake to make it available on the command line. In the <em>bin</em> directory, add a Python script called <a href="hello/hello">hello</a> and make it executable with "chmod".</p>
<p>This command-line tool consists of two parts:</p>
<ul>
<li>Parsing command-line options. This is done using standard Python functionality in the OptionParser module. </li>
<li>Running a "hello" function that accesses the C code through the Python wrapper.</li>
</ul>
<p>After the "binary" has been written, don't forget to add it to the "install:" directive in <em>bin/Makefile</em>.</p>
<h2><a class="anchor" id="toolbox_qp"></a>
Create quality plugin</h2>
<p>The toolbox contains functionality for managing data processing algorithms at a high level of abstraction. These building blocks are referred to as "quality plugins". By registering plugins, they can be chained in memory automatically.</p>
<p>The plugin is found in <a href="hello/rave_hello_quality_plugin.py">Lib/rave_hello_quality_plugin.py</a>. In addition to the constructor, it contains a name defined in the <em>getQualityfields</em> method. This name follows a convention that is Java-like and represents the hierarchical origin of the algorithm that can be used to identify it. This name should written to an output file's <code>how/task</code> attribute, but it is the responsibility of each tool to ensure this.</p>
<p>The registry itself is located in <em>etc/rave_pgf_quality_registry.xml</em>. The following entry should be added:</p>
<p><code> &lt;quality-plugin name="hello" module="rave_hello_quality_plugin" class="hello_plugin"/&gt;</code></p>
<p>Once this "hello" quality plugin has been registered, it can be verified using the <em>odc_toolbox</em> tool on the command-line. Assuming the bRopo and beamb packages have also been installed, you can set up the following:</p>
<ul>
<li>Create two directories call "in" and "out". </li>
<li>Place an ODIM_H5 file in the "in" directory. </li>
<li>Run: <code>odc_toolbox -i in -o out -q 'ropo,radvol-att,beamb,hello'</code></li>
</ul>
<p>Then check the output file in the "out" directory, e.g. using HDFView or h5dump. It should be larger and contain quality indicator fields from the various quality controls, including the greeting created by "hello".</p>
<h2><a class="anchor" id="toolbox_pgf"></a>
Create a PGF plugin</h2>
<p>In contrast to the quality plugins, PGF plugins are used by a BALTRAD node running in real time as part of the PGF server operating as a daemon. This server received XML-RPC messages containing information on which tool to run among other things. It must therefore have a mechanism for looking up these tools. This is the purpose of this kind of plugin.</p>
<p>In the case of "hello", its PGF plugin is found in <a href="hello/rave_pgf_hello_plugin.py">Lib/rave_pgf_hello_plugin.py</a>. This plugin, like all PGF plugins, must have a function called <code>generate</code> that takes two manadatory arguments: <code>files</code> and <code>arguments</code>. More information is available in the <a href="http://git.baltrad.eu/manual/rave/rave_pgf.html">PGF server documentation</a>.</p>
<p>Register the plugin:</p>
<div class="fragment"><pre class="fragment">
$ pgf_registry -a -H http://localhost:8085/RAVE --name=eu.baltrad.beast.hello -m rave_pgf_hello_plugin -f generate -d 'Hello tutorial'
</pre></div><p>Verify:</p>
<div class="fragment"><pre class="fragment">
$ pgf_registry -l -H http://localhost:8085/RAVE
</pre></div><p>Test:</p>
<p>This test will actually use a simple client that will connect to your PGF server and tell it to run the "hello" PGF plugin on it. The client is <a href="hello/hello_pgf">hello_pgf</a>.</p>
<p>First, start your PGF server if it isn't already running:</p>
<div class="fragment"><pre class="fragment">
$ rave_pgf start
</pre></div><p>Then using an input ODIM_H5 file, e.g. pvol.h5:</p>
<div class="fragment"><pre class="fragment">
$ hello_pgf pvol.h5
</pre></div><h2><a class="anchor" id="toolbox_beast"></a>
Integrate with Beast and BALTRAD node</h2>
<p>This integration is only required if you are running a toolbox as part of a real-time BALTRAD node, or plan to. Prototyping a new <em>Route</em> is done in the Beast sub-system of a BALTRAD node, using Groovy scripting. This can be done rather quickly. Creating a proper graphical user interface for the route takes longer, but should be done once the scripted route has been verified to function as expected. This tutorial will only cover the <a href="http://git.baltrad.eu/manual/beast/doc/doxygen/p_groovyrules.html">scripted Groovy routes.</a></p>
<p><a href="hello/Hello.groovy">Hello.groovy</a> has been created for this tutorial. To activate it, in your node's user interface, create a new scipted route through the "Routes" --&gt; "Create script" menu and paste the script text into the script field. Don't forget to click on the RAVE <em>Recipient</em>. When the route has been configured, press the "Add" button and the route will trigger jobs automatically in real time. In this case, the triggering criterion is the presence of a polar scan or volume from Swedish radars &Auml;ngelholm and Arlanda.</p>
<div class="image">
<img src="create_script.png" alt="create_script.png"/>
</div>
<h2><a class="anchor" id="toolbox_rec"></a>
Final recommendations</h2>
<p><em>librave/toolbox</em> contains mostly infrastructure; please keep it that way.</p>
<p>Add your tools in one of the following ways:</p>
<ul>
<li>As a separate directory under <em>librave</em>, like e.g. radvol. </li>
<li>As a separate package that uses RAVE as a dependency, e.g. bRopo. </li>
</ul>
</div></div>


<hr class="footer"/><address class="footer"><small>
</a><a href="mailto:support@baltrad.eu">support@baltrad.eu</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generated on Tue Jun 17 2014 12:32:17 by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/> 1.7.4 for <a href="http://baltrad.eu/" target="_blank"><img class="footer" src="foot_BALTRAD-doxlogo.png" /></a></small></address>

</body>
</html>
